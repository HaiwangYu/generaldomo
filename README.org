#+title: Generaldomo

A somewhat generalized version of the ZeroMQ Majordomo pattern.

* You Douzo, I Domo

** Majordomo

The Majordomo pattern or protocol (MDP) consists of a broker bringing
clients together with workers via a "service" name in a reliable
manner and which allows a high degree of scaling out.  

There are a number of versions of MDP "in the wild". Version 1 (aka
0.1, aka ~MDPW01~ for worker and ~MDPC01~ for client sub-protocol) of MDP
is described in the [[http://zguide.zeromq.org/py:all#Asynchronous-Majordomo-Pattern][ZeroMQ Guide]] and specified in the stable ZeroMQ RFC
[[https://rfc.zeromq.org/spec/7/][7/MDP]].

Version 2 (aka 0.2, etc for sub-protocols) is specified in draft
ZeroMQ RFC [[https://rfc.zeromq.org/spec/18/][18/MDP]].  This version extends 7/MDP to allow a worker to
reply with a stream of messages.

An unspecified version "0.3" can be found in the [[https://github.com/zeromq/majordomo/tree/master/libmdp][libmdp/]] directory
with some description of the changes w.r.t. 18/MDP in [[https://github.com/zeromq/majordomo/issues/34][majordomo#34]].

At some point, the 18/MDP implementation in the main part of the
repository was changed from hand-crafted to one that is partially
generated by [[https://github.com/zeromq/zproto][Zproto]].  As it uses the standard Zproto client/server
templates, the packing of messages led to a deviation in 18/MDP.  In
particular, there is a leading two byte "signature" (~0xAAA4~), the
initial fields described in 18/MDP are packed into a single frame and
zproto message IDs are included in addition to the IDs specified by
18/MDP.

Copies of the Majordomo Python examples from the guide, updated for
Python3, are in [[file:md/][md/]] for reference.

** Generaldomo

The Generaldomo Package (GDP) generalizes 7/MDP starting with the
example code provided in the ZeroMQ guide.  GDP is a superset which
simplifies to 7/MDP when ROUTER is used for the broker.  The extension
only applies when the router uses a SERVER socket.  In the remainder,
GDP will refer to this extension although strictly GDP also
encompasses 7/MDP.

The main motivation for GDP is to support clients or workers to run in
threaded environments that will cause problems with non-thread-safe
DEALER/ROUTER.  

As CLIENT/SERVER do not support multipart messages needed for 7/MDP
GDP is essentially defined by how otherwise 7/MDP-compliant multi-part
messages are packed into a single-part.  This packing is done by
prefixing the data of one part (one frame) with a 32 bit value holding
the size of that part in bytes and concatenating the result to form
the single-part message.

FIXME: check into exactly how ZeroMQ packets multi-part and use the
same definition here.

* Install

** C++

*** Installation requirements

The Generaldomo C++17 API requires ~libzmq~ to have been built with
"draft" sockets.  The easiest way to do this is by installing from
recent "master" branch of the official repository.  ZeroMQ community
tends to keep "master" working well with each commit essentially being
a new release.

#+begin_example
  $ git clone https://github.com/zeromq/libzmq.git
  $ cd libzmq/
  $ ./autogen.sh
  $ ./configure --prefix=$HOME/opt/zmq
  $ make -j$(nproc)
  $ make install
#+end_example

The [[https://github.com/zeromq/cppzmq][cppzmq]] C++ interface to ~libzmq~ is used by generaldomo C++ library.  It essentially consists of two header files which are included directly an no installation is required.

*** Install

The C++ API installs with ~waf~.  Assuming ~libzmq~ was installed as
above, Generaldomo C++ API may be installed as:

#+begin_example
  $ wget -O ~/bin/waf https://waf.io/waf-2.0.19
  $ chmod ~/bin/waf

  $ export PKG_CONFIG_PATH=$HOME/opt/zmq/lib/pkgconfig
  $ waf configure --prefix=$HOME/opt/zmq
#+end_example



** Python

Generaldomo Python API requires Python 3 and is independent from the
C++ API.  PyZMQ is required and must provide the "draft" sockets.
Assuming ~libzmq~ was installed as above the following commands will
provide a suitable Python environment in which to install and use
Generaldomo Python API.

#+begin_example
  $ python3 -m venv /path/to/venv
  $ source /path/to/venv/bin/activate
  $ pip install --pre pyzmq \
      --install-option=--enable-drafts \
      --install-option=--zmq=/path/to/zmq
  $ pip install -r requirements.txt
  $ pip install [-e] .
#+end_example

* Use

All example programs are exposed through a common ~generaldomo~ CLI.

  #+begin_export 
  $ generaldomo --help  
  #+end_export

The simple, self-contained "tripping" example with one or the other
"serverish" socket type:

#+begin_example
  $ generaldomo tripping -n 1000 -f router -b router
  $ generaldomo tripping -n 1000 -f server -b server
#+end_example

To run the full Majordomo example, run each in three terminals:

#+begin_example
$ generaldomo broker --verbose -s server
$ generaldomo echo --verbose -s client
$ generaldomo client --verbose -n 2 -s client echo hello world
#+end_example

Likewise this trio can be run with the ROUTER/DEALER socket types.
The ~broker~ taking ~-s router~ with ~echo~ and ~client~ taking ~-s dealer~.

* Internals

As described above, Generaldomo generalizes Majordomo 7/MDP to allow a
choice between SERVER or ROUTER for the broker.  This flexibility may
be achieved by developing two separate implementations for the broker.
However, the differences between the two socket patterns is not deep.
At the cost of some additional copying we can provide a sort of
type-erasure.  

The first step is to understand that the two sockets differ in two
orthogonal ways.

- message parts :: SERVER produces single-part, ROUTER produces multi-part 
- routing IDs :: SERVER attaches the ID as message metadata, ROUTER
                 prefixes a stack of N (in general) IDs, each ID in an
                 individual frame to the message (address envelope
                 stack).  SERVER IDs are 32 bit unsigned ints, ROUTER
                 IDs are 1 to 255 bytes with the first byte non-zero.

These differences can be "erased" at the point of sending and
receiving a message.  A convention is chosen for the higher level
broker code is chosen and the low level ~send()/recv()~ calls are
wrapped with code that switches on the socket type

The convention chosen is as follows:

- routing ID :: the routing ID is held in a variant data structure
                which is treated opaque by the higher level code.  It
                holds a ~uint32_t~ in the case of a SERVER and it holds
                the address envelope stack as a multipart message in
                the case of a ROUTER.

- payload :: the non-ID part of the message is presented as a
             multipart message identical to as described in 7/MDP.
             For ROUTER, the address envelope stack is stripped and
             the remainder of the multipart is 7/MDP.  For SERVER, the
             single-part message is decoded to multipart.  The
             encoding/decoding follows the scheme of CZMQ ~zmsg_t/zframe_t~.

